// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=github.com/ztx/andra/example/design
// --out=$(GOPATH)/src/github.com/ztx/andra/example
// --version=v1.1.0-dirty
//
// API "entp": Models
//
// The content of this file is auto-generated, DO NOT MODIFY

package cassandra

import (
	"github.com/goadesign/goa"
	"github.com/jinzhu/gorm"
	"github.com/ztx/andra/example/app"
	"github.com/ztx/andra/example/models"
	"golang.org/x/net/context"
	"strings"
	"time"
)

type PrLine struct {
	*models.PrLine
}

type PrLineModel struct {
	models.PrLineStorage
}

//
func (m PrLine) ColumnOf(attrib string) string {
	out := ""
	switch attrib {
	case "ID":
		out = "id"
	case "ItemCode":
		out = "item_code"
	case "PrID":
		out = "pr_id"
	case "Price":
		out = "price"
	case "Qty":
		out = "qty"
	case "Sl":
		out = "sl"
	}
	return out
}

func (m PrLine) ColumnsOf(attribs ...string) []string {
	out := []string{}
	for _, s := range attribs {
		out = append(out, m.ColumnOf(s))
	}
	return out
}

func (m *PrLine) SelectCQL(attribs ...string) (query string, values []interface{}, err error) {
	//leave the validation of attribute names to ValueHolders
	//as it will panic for invalid attribute names

	values = m.ValueHolders(attribs...)
	columns := make([]string, len(attribs))
	for i, a := range attribs {
		columns[i] = m.ColumnOf(a)
	}
	query = "SELECT " +
		strings.Join(columns, ",") +
		" FROM " +
		m.TableName() +
		" WHERE "

	whereCond := []string{}
	whereValues := []interface{}{}

	for _, k := range m.PrimaryKeys() {
		whereCond = append(whereCond, k+"=?")
		whereValues = append(whereValues, m.ValueHolder(k))
	}

	query = query + strings.Join(whereCond, " AND ")
	values = append(values, whereValues...)
	return
}

//Model returns the containing model
func (m *PrLine) Model() *models.PrLine {
	return m.PrLine
}

func (m PrLine) InsertCQL() (query string, values []interface{}, err error) {
	query = "INSERT INTO " + m.TableName()
	columns := []string{}
	columnValues := []interface{}{}

	if m.ID != nil {
		columns = append(columns, m.ColumnOf("ID"))
		columnValues = append(columnValues, &m.ID)
	}

	if m.ItemCode != nil {
		columns = append(columns, m.ColumnOf("ItemCode"))
		columnValues = append(columnValues, &m.ItemCode)
	}

	if m.PrID != nil {
		columns = append(columns, m.ColumnOf("PrID"))
		columnValues = append(columnValues, &m.PrID)
	}

	if m.Price != nil {
		columns = append(columns, m.ColumnOf("Price"))
		columnValues = append(columnValues, &m.Price)
	}

	if m.Qty != nil {
		columns = append(columns, m.ColumnOf("Qty"))
		columnValues = append(columnValues, &m.Qty)
	}

	if m.Sl != nil {
		columns = append(columns, m.ColumnOf("Sl"))
		columnValues = append(columnValues, &m.Sl)
	}

	query = query + strings.Join(columns, ",") + ")"
	query = query + " VALUES("
	for range columnValues {
		query = query + "?,"
	}
	//remove trailing ","
	query = query[0 : len(query)-1]
	query = query + ")"
	values = columnValues
	return
}

// Belongs To Relationships

// PrLineFilterByPr is a gorm filter for a Belongs To relationship.
func PrLineFilterByPr(prID int, originaldb *gorm.DB) func(db *gorm.DB) *gorm.DB {
	if prID > 0 {
		return func(db *gorm.DB) *gorm.DB {
			return db.Where("pr_id = ?", prID)

		}
	}
	return func(db *gorm.DB) *gorm.DB { return db }
}

// CRUD Functions

// Get returns a single PrLine as a Database Model
// This is more for use internally, and probably not what you want in  your controllers
func (m *PrLineModel) Get(ctx context.Context, id *int) (*PrLine, error) {
	defer goa.MeasureSince([]string{"goa", "db", "prLine", "get"}, time.Now())

	var native PrLine
	err := m.Db.Table(m.TableName()).Where("id = ?", id).Find(&native).Error
	if err == gorm.ErrRecordNotFound {
		return nil, err
	}

	return &native, err
}

// List returns an array of PrLine
func (m *PrLineModel) List(ctx context.Context) ([]*PrLine, error) {
	defer goa.MeasureSince([]string{"goa", "db", "prLine", "list"}, time.Now())

	var objs []*PrLine
	err := m.Db.Table(m.TableName()).Find(&objs).Error
	if err != nil && err != gorm.ErrRecordNotFound {
		return nil, err
	}

	return objs, nil
}

// Add creates a new record.
func (m *PrLineModel) Add(ctx context.Context, model *PrLine) error {
	defer goa.MeasureSince([]string{"goa", "db", "prLine", "add"}, time.Now())

	err := m.Db.Create(model).Error
	if err != nil {
		goa.LogError(ctx, "error adding PrLine", "error", err.Error())
		return err
	}

	return nil
}

// Update modifies a single record.
func (m *PrLineModel) Update(ctx context.Context, model *PrLine) error {
	defer goa.MeasureSince([]string{"goa", "db", "prLine", "update"}, time.Now())

	obj, err := m.Get(ctx, model.ID)
	if err != nil {
		goa.LogError(ctx, "error updating PrLine", "error", err.Error())
		return err
	}
	err = m.Db.Model(obj).Updates(model).Error

	return err
}

// Delete removes a single record.
func (m *PrLineModel) Delete(ctx context.Context, id *int) error {
	defer goa.MeasureSince([]string{"goa", "db", "prLine", "delete"}, time.Now())

	var obj PrLine

	err := m.Db.Delete(&obj, id).Error

	if err != nil {
		goa.LogError(ctx, "error deleting PrLine", "error", err.Error())
		return err
	}

	return nil
}

// PrLineFromCreatePrLinePayload Converts source CreatePrLinePayload to target PrLine model
// only copying the non-nil fields from the source.
func PrLineFromCreatePrLinePayload(payload *app.CreatePrLinePayload) *PrLine {
	prline := &PrLine{}
	prline.Price = payload.Price
	prline.Qty = payload.Qty
	prline.Sl = payload.Sl

	return prline
}

// UpdateFromCreatePrLinePayload applies non-nil changes from CreatePrLinePayload to the model and saves it
func (m *PrLineModel) UpdateFromCreatePrLinePayload(ctx context.Context, payload *app.CreatePrLinePayload, id *int) error {
	defer goa.MeasureSince([]string{"goa", "db", "prLine", "updatefromcreatePrLinePayload"}, time.Now())

	var obj PrLine
	err := m.Db.Table(m.TableName()).Where("id = ?", id).Find(&obj).Error
	if err != nil {
		goa.LogError(ctx, "error retrieving PrLine", "error", err.Error())
		return err
	}
	obj.Price = payload.Price
	obj.Qty = payload.Qty
	obj.Sl = payload.Sl

	err = m.Db.Save(&obj).Error
	return err
}
