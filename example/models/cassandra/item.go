// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=github.com/ztx/andra/example/design
// --out=$(GOPATH)/src/github.com/ztx/andra/example
// --version=v1.1.0-dirty
//
// API "entp": Models
//
// The content of this file is auto-generated, DO NOT MODIFY

package cassandra

import (
	"github.com/goadesign/goa"
	"github.com/jinzhu/gorm"
	"github.com/ztx/andra/example/app"
	"github.com/ztx/andra/example/models"
	"golang.org/x/net/context"
	"strings"
	"time"
)

type Item struct {
	*models.Item
}

type ItemModel struct {
	models.ItemStorage
}

//
func (m Item) ColumnOf(attrib string) string {
	out := ""
	switch attrib {
	case "Code":
		out = "code"
	case "ID":
		out = "id"
	case "Name":
		out = "name"
	case "Uom":
		out = "uom"
	}
	return out
}

func (m Item) ColumnsOf(attribs ...string) []string {
	out := []string{}
	for _, s := range attribs {
		out = append(out, m.ColumnOf(s))
	}
	return out
}

func (m *Item) SelectCQL(attribs ...string) (query string, values []interface{}, err error) {
	//leave the validation of attribute names to ValueHolders
	//as it will panic for invalid attribute names

	values = m.ValueHolders(attribs...)
	columns := make([]string, len(attribs))
	for i, a := range attribs {
		columns[i] = m.ColumnOf(a)
	}
	query = "SELECT " +
		strings.Join(columns, ",") +
		" FROM " +
		m.TableName() +
		" WHERE "

	whereCond := []string{}
	whereValues := []interface{}{}

	for _, k := range m.PrimaryKeys() {
		whereCond = append(whereCond, k+"=?")
		whereValues = append(whereValues, m.ValueHolder(k))
	}

	query = query + strings.Join(whereCond, " AND ")
	values = append(values, whereValues...)
	return
}

//Model returns the containing model
func (m *Item) Model() *models.Item {
	return m.Item
}

func (m Item) InsertCQL() (query string, values []interface{}, err error) {
	query = "INSERT INTO " + m.TableName()
	columns := []string{}
	columnValues := []interface{}{}

	if m.Code != nil {
		columns = append(columns, m.ColumnOf("Code"))
		columnValues = append(columnValues, &m.Code)
	}

	if m.ID != nil {
		columns = append(columns, m.ColumnOf("ID"))
		columnValues = append(columnValues, &m.ID)
	}

	if m.Name != nil {
		columns = append(columns, m.ColumnOf("Name"))
		columnValues = append(columnValues, &m.Name)
	}

	if m.Uom != nil {
		columns = append(columns, m.ColumnOf("Uom"))
		columnValues = append(columnValues, &m.Uom)
	}

	query = query + strings.Join(columns, ",") + ")"
	query = query + " VALUES("
	for range columnValues {
		query = query + "?,"
	}
	//remove trailing ","
	query = query[0 : len(query)-1]
	query = query + ")"
	values = columnValues
	return
}

// CRUD Functions

// Get returns a single Item as a Database Model
// This is more for use internally, and probably not what you want in  your controllers
func (m *ItemModel) Get(ctx context.Context, id *int) (*Item, error) {
	defer goa.MeasureSince([]string{"goa", "db", "item", "get"}, time.Now())

	var native Item
	err := m.Db.Table(m.TableName()).Where("id = ?", id).Find(&native).Error
	if err == gorm.ErrRecordNotFound {
		return nil, err
	}

	return &native, err
}

// List returns an array of Item
func (m *ItemModel) List(ctx context.Context) ([]*Item, error) {
	defer goa.MeasureSince([]string{"goa", "db", "item", "list"}, time.Now())

	var objs []*Item
	err := m.Db.Table(m.TableName()).Find(&objs).Error
	if err != nil && err != gorm.ErrRecordNotFound {
		return nil, err
	}

	return objs, nil
}

// Add creates a new record.
func (m *ItemModel) Add(ctx context.Context, model *Item) error {
	defer goa.MeasureSince([]string{"goa", "db", "item", "add"}, time.Now())

	err := m.Db.Create(model).Error
	if err != nil {
		goa.LogError(ctx, "error adding Item", "error", err.Error())
		return err
	}

	return nil
}

// Update modifies a single record.
func (m *ItemModel) Update(ctx context.Context, model *Item) error {
	defer goa.MeasureSince([]string{"goa", "db", "item", "update"}, time.Now())

	obj, err := m.Get(ctx, model.ID)
	if err != nil {
		goa.LogError(ctx, "error updating Item", "error", err.Error())
		return err
	}
	err = m.Db.Model(obj).Updates(model).Error

	return err
}

// Delete removes a single record.
func (m *ItemModel) Delete(ctx context.Context, id *int) error {
	defer goa.MeasureSince([]string{"goa", "db", "item", "delete"}, time.Now())

	var obj Item

	err := m.Db.Delete(&obj, id).Error

	if err != nil {
		goa.LogError(ctx, "error deleting Item", "error", err.Error())
		return err
	}

	return nil
}

// ItemFromCreateItemPayload Converts source CreateItemPayload to target Item model
// only copying the non-nil fields from the source.
func ItemFromCreateItemPayload(payload *app.CreateItemPayload) *Item {
	item := &Item{}
	item.Code = payload.Code
	item.Name = payload.Name
	item.Uom = payload.Uom

	return item
}

// UpdateFromCreateItemPayload applies non-nil changes from CreateItemPayload to the model and saves it
func (m *ItemModel) UpdateFromCreateItemPayload(ctx context.Context, payload *app.CreateItemPayload, id *int) error {
	defer goa.MeasureSince([]string{"goa", "db", "item", "updatefromcreateItemPayload"}, time.Now())

	var obj Item
	err := m.Db.Table(m.TableName()).Where("id = ?", id).Find(&obj).Error
	if err != nil {
		goa.LogError(ctx, "error retrieving Item", "error", err.Error())
		return err
	}
	obj.Code = payload.Code
	obj.Name = payload.Name
	obj.Uom = payload.Uom

	err = m.Db.Save(&obj).Error
	return err
}
